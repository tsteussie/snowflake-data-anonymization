import snowflake.snowpark as snowpark
from snowflake.snowpark.functions import *
from snowflake.snowpark.types import *
from datetime import datetime
import re

# -------- Specify user inputs -------- #

# Email address to search for
email_submitted = "toddsteussie@gmail.com"

# Databases and schema to search
databases = ["DEV_COPY", "PRD_COPY", "PRD_LAKE"]
schema = "PUBLIC"

# SQL template to identify email-related columns
sql_template = f"""
SELECT
    'SELECT ' || COLUMN_NAME ||
    ' FROM ' || TABLE_SCHEMA || '.' || TABLE_NAME ||
    ' WHERE ' || COLUMN_NAME || ' IN (''{email_submitted}'');' AS query,
    TABLE_NAME,
    TABLE_SCHEMA,
    COLUMN_NAME
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME IN (
    SELECT a.table_name
    FROM INFORMATION_SCHEMA.TABLES a
    WHERE a.table_type = 'BASE TABLE'
      AND a.table_name IN (
        SELECT TABLE_NAME
        FROM INFORMATION_SCHEMA.COLUMNS b
        WHERE b.COLUMN_NAME ILIKE '%email%'
      )
)
AND COLUMN_NAME ILIKE '%email%'
AND DATA_TYPE IN ('TEXT', 'VARCHAR')
"""

# Snowflake connection parameters
connection_parameters = {
    "role": "SYSADMIN",
    "warehouse": "DNA_WH",
}

# -------- Execute Main Function -------- #

def main(session: snowpark.Session):
    combined_results = []

    for db in databases:
        session.use_database(db)
        session.use_schema(schema)

        result_df = session.sql(sql_template)
        queries = result_df.collect()

        for row in queries:
            query = row["QUERY"]
            table_name = row["TABLE_NAME"]
            table_schema = row["TABLE_SCHEMA"]
            column_name = row["COLUMN_NAME"]

            select_all_query = f"SELECT * FROM {db}.{table_schema}.{table_name} WHERE {column_name} IN ('{email_submitted}');"

            print("üîç Executing search query:", query)
            print("üìÑ Full object name:", f"{db}.{table_schema}.{table_name}")

            try:
                customer_df = session.sql(f"""
                    SELECT COLUMN_NAME
                    FROM {db}.INFORMATION_SCHEMA.COLUMNS
                    WHERE TABLE_NAME = '{table_name}'
                        AND COLUMN_NAME ILIKE ANY (...)
                """)
                customer_list = list(dict.fromkeys([r["COLUMN_NAME"] for r in customer_df.collect()]))
            except Exception as e:
                customer_list = [f"<error: {str(e)}>"]

            try:
                related_df = session.sql(f"""
                    SELECT COLUMN_NAME
                    FROM {db}.INFORMATION_SCHEMA.COLUMNS
                    WHERE TABLE_NAME = '{table_name}'
                        AND COLUMN_NAME ILIKE ANY (...)
                """)
                related_list = list(dict.fromkeys([r["COLUMN_NAME"] for r in related_df.collect()]))
            except Exception as e:
                related_list = [f"<error: {str(e)}>"]

            customer_set = set(customer_list)
            related_set = set(related_list)
            all_columns = list(dict.fromkeys(customer_list + related_list))

            customer_columns = ", ".join(customer_set)
            related_columns = ", ".join(related_set)

            try:
                result = session.sql(query).collect()
                for r in result:
                    combined_results.append((query, str(r), db, schema, select_all_query, customer_columns, related_columns))
                if not result:
                    combined_results.append((query, "<no match>", db, schema, select_all_query, customer_columns, related_columns))
            except Exception as e:
                combined_results.append((query, f"<error: {str(e)}>", db, schema, select_all_query, customer_columns, related_columns))

    result_schema = StructType([
        StructField("query", StringType()),
        StructField("result", StringType()),
        StructField("database", StringType()),
        StructField("schema", StringType()),
        StructField("select_all_query", StringType()),
        StructField("customer_columns", StringType()),
        StructField("related_columns", StringType())
    ])

    combined_results = [r if len(r) == 7 else r + ("",) * (7 - len(r)) for r in combined_results]
    result_df = session.create_dataframe(combined_results, schema=result_schema)

    result_df = result_df.filter(
        (col("result").is_not_null()) &
        (col("result") != lit("<no match>")) &
        (trim(left(col("result"), 7)) != lit("<error:"))
    )

    if result_df.count() == 0:
        print("‚ö†Ô∏è No matching records found. Skipping update and log write.")
        return None

    result_df = result_df.drop('result', 'query') \
        .with_column("email_address", lit(email_submitted)) \
        .with_column("search_datetime", current_timestamp()) \
        .drop_duplicates('select_all_query')

    result_df.write.mode("append").save_as_table("prd_mart.data_anonymization.search_records_log")

    latest_time = session.table("prd_mart.data_anonymization.search_records_log").agg(max("search_datetime").alias("latest_time")).collect()[0]["LATEST_TIME"]

    log_df = session.table("prd_mart.data_anonymization.search_records_log")\
        .filter(col("search_datetime") == lit(latest_time))\
        .select("database", "schema", "select_all_query", "customer_columns", "related_columns")

    if log_df.count() == 0:
        print("‚ö†Ô∏è No update log entries found ‚Äî skipping update process.")
        return None

    for row in log_df.collect():
        db = row["DATABASE"]
        select_query = row["SELECT_ALL_QUERY"]
        customer_cols = row["CUSTOMER_COLUMNS"]
        related_cols = row["RELATED_COLUMNS"]

        print("üîÑ Preparing update for:", select_query)

        customer_set = set(c.strip() for c in customer_cols.split(",") if c.strip())
        related_set = set(c.strip() for c in related_cols.split(",") if c.strip())

        column_update_map = {col: "'Removed'" for col in customer_set}
        for col in related_set - customer_set:
            column_update_map[col] = "''"

        update_sets = [f"{col} = {val}" for col, val in column_update_map.items()]
        if not update_sets:
            continue

        match = re.match(r"SELECT \* FROM (.+?) WHERE (.+);", select_query)
        if not match:
            continue

        full_table = match.group(1)
        where_clause = match.group(2)

        try:
            session.sql(f"GRANT UPDATE ON {full_table} TO ROLE SYSADMIN").collect()
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to grant update on {full_table}: {e}")

        update_sql = f"UPDATE {full_table} SET {', '.join(update_sets)} WHERE {where_clause};"
        print("üõ† Executing update SQL:", update_sql)

        try:
            update_result = session.sql(update_sql).collect()
            rows_updated = update_result[0]['rows_updated'] if update_result and 'rows_updated' in update_result[0] else "unknown"
            print(f"‚úÖ Updated {full_table} ‚Äî Rows affected: {rows_updated}")
        except Exception as e:
            print(f"‚ùå Error updating {full_table}: {e}")

    if result_df.count() == 0:
        print("‚ö†Ô∏è No updates occurred, skipping summary logging.")
        return None

    session.sql("""
    CREATE TABLE IF NOT EXISTS PRD_MART.DATA_ANONYMIZATION.COMPLETED_REQUESTS (
        CUSTOMER_EMAIL STRING,
        UPDATE_DATETIME TIMESTAMP_NTZ,
        DATABASES_UPDATED INT,
        TABLES_UPDATED INT,
        COLUMNS_UPDATED INT
    )
    """).collect()

    databases_updated = set()
    tables_updated = set()
    columns_updated = 0

    for row in result_df.collect():
        db = row["DATABASE"]
        query = row["SELECT_ALL_QUERY"]
        customer_cols = row["CUSTOMER_COLUMNS"]
        related_cols = row["RELATED_COLUMNS"]

        databases_updated.add(db)

        match = re.match(r"SELECT \* FROM\s+([^.]+\.[^.]+\.[^.]+)\s+WHERE", query)
        if match:
            tables_updated.add(match.group(1))

        columns_updated += len(set(c.strip() for c in (customer_cols + "," + related_cols).split(",") if c.strip()))

    summary_data = [(
        email_submitted,
        datetime.now(),
        len(databases_updated),
        len(tables_updated),
        columns_updated
    )]

    summary_schema = StructType([
        StructField("CUSTOMER_EMAIL", StringType()),
        StructField("UPDATE_DATETIME", TimestampType()),
        StructField("DATABASES_UPDATED", IntegerType()),
        StructField("TABLES_UPDATED", IntegerType()),
        StructField("COLUMNS_UPDATED", IntegerType())
    ])

    summary_df = session.create_dataframe(summary_data, schema=summary_schema)
    summary_df.write.mode("append").save_as_table("PRD_MART.DATA_ANONYMIZATION.COMPLETED_REQUESTS")

    print("‚úÖ Script completed. Review logs for details.")
    return session.table("PRD_MART.DATA_ANONYMIZATION.COMPLETED_REQUESTS")
